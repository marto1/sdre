from re import split
from random import choice
import logging
import structure

logging.basicConfig(format='%(levelname)s:%(message)s', level=logging.DEBUG)

class Goal(object):
    """Sentence to be generated"""
    placeholder_words = ["oh", "ok", "what"]

    def __init__(self, goal_string=""):
        self.goal_string = goal_string
        self.symbol_parse = {".": self.parse_placeholder,}
                             #" ": self.parse_space}

    def generate_placeholder_words(self, tokens, index):
        pass

    def parse_placeholder(self, tokens, index):
        """
        Placeholders are generated by choosing random word
        from specified set.
        """
        self.generate_placeholder_words(tokens, index)
        return choice(self.placeholder_words)

    def tokenize(self):
        return split(" ", self.goal_string)

    def compile(self):
        tokens = self.tokenize()
        for index in xrange(len(tokens)):
            token = tokens[index]
            if token in self.symbol_parse:
                r = self.symbol_parse[token](tokens, index)
                tokens[index] = r
        return tokens

class GoalV2(object):
    """
    A more generalized goal.  Goals are going to be used as actors
    that "bounce" words between themselves and reach an agreement.
    Their behaviour is defined from external world and internal world.
    The external is all variation of external conditions that
    the goal considers. The internal is the goal specific inclinations
    which togheter should form a "formula" for the goal. 

    Goals should also lead a "conversation" with the user by telling him 
    on why they are voting with a given score. 
    """

    def bounce(self, word, context):
        """ Rank a word for a given context. """



class MinimumBounces(GoalV2):

    def __init__(self):
        self.bounces = 0
        self.tresh = 2

    def bounce(self, word, context):
        self.bounces += 1
        if self.bounces >= self.tresh:
            logging.info("Too many bounces for me, voting down")
            return max(context["min_score"], context["max_score"] - self.bounces)
        else:
            logging.info("Bounces are low, voting with max score")
            return context["max_score"]        

class LikeTheLetterA(GoalV2):

    def bounce(self, word, context):
        if "a" in word:
            logging.info("I like the letter \"a\", voting with max score")
            return context["max_score"]
        else:
            logging.info("No \"a\" in this word, whatever - 0")
            return 0

class ShortWords(GoalV2):
    
    def bounce(self, word, context):
        if len(word) >= 3: #long words have more than 3 letters
            logging.info("The word is too long, whatever")
            return max(0, context["max_score"] - len(word))
        else:
            logging.info("The word is short, voting with max score")
            return context["max_score"]

class UserInput(GoalV2):

    def bounce(self, word, context):
        logging.info("Is {0}  ok[1] or not[0]:".format(word))
        user = structure.getch()
        if user == '1':
            logging.info("User likes this word, voting up")
            return context["max_score"]
        else:
            logging.info("User doesn't like this word, voting down")
            return context["min_score"]
        

def agree_on_no_less_than(number, goals, context, iterations=100):
    context["current_score"] = context['original_score']
    it = 0
    word = context['word']
    while True:
        r = [g.bounce(word, context) for g in goals]
        context["current_score"] += sum(r)
        if context["current_score"] >= number:
            return context["current_score"]
        if it == iterations:
            logging.warning("reached iteration limit for word \"{0}\"".format(word))
            return context["current_score"]
        it += 1

context = { "max_score": 5,
            "min_score": -5,
            "original_score": 30,
            "word": "Bianca",
            "current_score" : 30,
            "sentence": ".  please stop using my room"}

make_goals = lambda: (MinimumBounces(), LikeTheLetterA(), ShortWords())


print "Score:", agree_on_no_less_than(500, make_goals(), context)

context["word"] = "room"

print "Score:", agree_on_no_less_than(500, make_goals(), context)


#Goal.generate_placeholder_words = lambda self, tokens, index: 2
# p = Goal(". expressions have . rules! Dude what the fuck .")
# print p.compile()
